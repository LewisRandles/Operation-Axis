export default async function operationAxis (apiConfig) { const ca = Object.defineProperty; const pt = (t) => (a) => { const e = t[a]; if (e) return e(); throw new Error("Module not found in bundle: " + a); }; const c = (t, a) => () => (t && (a = t(t = 0)), a); const l = (t, a) => { for (const e in a)ca(t, e, { "get": a[e], "enumerable": !0 }); }; const L = {}; l(L, { "errorStatus": () => la }); let la; const A = c(() => { la = { "status": !0, "lastError": {}, "errorList": [] }; }); const wt = {}; l(wt, { "formError": () => ua }); async function ua (t, a) { let { "errorStatus": e } = await Promise.resolve().then(() => (A(), L)); a = a === "unknown" ? "unknown" : `${a}.js`; let n = new Error().stack.toString().match(/([A-Za-z0-9_$-]+) \(([^)]+)\)/g); n.splice(0, 2); let s = []; for await (let m of n) { let u = m.split(" "); let f = u[0]; let x = u[1].replace(/[()]/g, "").split("/"); let b = x[x.length - 1].split(":")[0]; s.push({ "function": f, "file": b }); } let o = { "code": t, "functionName": s[0].function, "currentName": s[0].file, "originalName": a }; console.log(o), t !== "warning" && (e.status = !1), e.lastError = o, e.errorList.push(o); } const ft = c(() => {}); const O = {}; l(O, { "patterns": () => ma }); let ma; const D = c(() => { ma = { "pattern1": /[^a-zA-Z]+/g, "pattern2": /\s{2,}/g, "pattern3": /\s/g, "pattern4": /^[A-Za-z0-9]+$/i, "pattern5": /^[A-Za-z0-9\s]+$/i, "pattern6": /([Zz]|[+-]\d{2}:\d{2})$/, "pattern7": /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern8": /^(0[1-9]|[12]\d|3[01])-(0[1-9]|1[0-2])-(\d{4})(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern9": /^\d+(\.\d+)?$/, "pattern10": /^[A-Za-z0-9\s()]+$/ }; }); const y = {}; l(y, { "typeID": () => pa }); async function pa (t) { let { "patterns": a } = await Promise.resolve().then(() => (D(), O)); return Object.prototype.toString.call(t).split(" ")[1].replace(a.pattern1, "").toLowerCase(); } const g = c(() => {}); const v = {}; l(v, { "spaceFormat": () => wa }); async function wa (t, a) { let { "patterns": e } = await Promise.resolve().then(() => (D(), O)); return a === "singleSpace" ? String(t).replace(e.pattern2, " ") : a === "noSpace" ? String(t).replace(e.pattern3, "") : (await errorHandle(1267, "spaceFormat"), !1); } const S = c(() => {}); const j = {}; l(j, { "isNully": () => fa }); async function fa (t) { let { "typeID": a } = await Promise.resolve().then(() => (g(), y)); let { "spaceFormat": e } = await Promise.resolve().then(() => (S(), v)); switch (await a(t)) { case "number": return isNaN(t); case "null": case "undefined": return !0; case "string": return (await e(String(t), "singleSpace")).trim().length === 0; default: return !1; } } const I = c(() => {}); const p = {}; l(p, { "errorHandle": () => da }); async function da (t, a) { let { "errorStatus": e } = await Promise.resolve().then(() => (A(), L)); let { "formError": r } = await Promise.resolve().then(() => (ft(), wt)); let { "isNully": i } = await Promise.resolve().then(() => (I(), j)); if (await i(t)) await r("unknown", "unknown"); else { if (t === "status") return !!e.status; (await i(a)) || (t === "warning" ? await r(t, a) : t >= 1111 && t <= 9999 ? await r(t, a) : await r("unknown", "unknown")); } } const w = c(() => {}); const dt = {}; l(dt, { "conditionString": () => ha }); async function ha (t, a) { let { "typeID": e } = await Promise.resolve().then(() => (g(), y)); let { "spaceFormat": r } = await Promise.resolve().then(() => (S(), v)); if ((await e(t)) === "string") { let i = await r(String(t), "singleSpace"); switch (String(a)) { case "1": return !0; default: return i.trim().length > 0; } } else return !1; } const ht = c(() => {}); const yt = {}; l(yt, { "conditionArray": () => ya }); async function ya (t, a) { let { "typeID": e } = await Promise.resolve().then(() => (g(), y)); if ((await e(t)) === "array") switch (String(a)) { case "1": return !0; default: return t.length !== 0; } else return !1; } const gt = c(() => {}); const xt = {}; l(xt, { "conditionObject": () => ga }); async function ga (t, a) { let { "typeID": e } = await Promise.resolve().then(() => (g(), y)); if ((await e(t)) === "object") switch (String(a)) { case "1": return !0; default: return Object.keys(t).length > 0 && Object.values(t).length > 0; } else return !1; } const Nt = c(() => {}); const kt = {}; l(kt, { "conditionNumber": () => xa }); async function xa (t, a) { let { "typeID": e } = await Promise.resolve().then(() => (g(), y)); if ((await e(t)) === "number") switch (String(a)) { case "1": return !0; default: return isNaN(t) === !1; } else return !1; } const bt = c(() => {}); const jt = {}; l(jt, { "conditionBoolean": () => Na }); async function Na (t) { let { "typeID": a } = await Promise.resolve().then(() => (g(), y)); return (await a(t)) === "boolean"; } const It = c(() => {}); const vt = {}; l(vt, { "conditionUndefined": () => ka }); async function ka (t) { let { "typeID": a } = await Promise.resolve().then(() => (g(), y)); return (await a(t)) === "undefined"; } const St = c(() => {}); const Lt = {}; l(Lt, { "conditionNull": () => ba }); async function ba (t) { let { "typeID": a } = await Promise.resolve().then(() => (g(), y)); return (await a(t)) === "null"; } const At = c(() => {}); const d = {}; l(d, { "conditionCheck": () => ja }); async function ja (t, a, e) { let { "conditionString": r } = await Promise.resolve().then(() => (ht(), dt)); let { "conditionArray": i } = await Promise.resolve().then(() => (gt(), yt)); let { "conditionObject": n } = await Promise.resolve().then(() => (Nt(), xt)); let { "conditionNumber": s } = await Promise.resolve().then(() => (bt(), kt)); let { "conditionBoolean": o } = await Promise.resolve().then(() => (It(), jt)); let { "conditionUndefined": m } = await Promise.resolve().then(() => (St(), vt)); let { "conditionNull": u } = await Promise.resolve().then(() => (At(), Lt)); switch (a) { case "string": return await r(t, e); case "array": return await i(t, e); case "object": return await n(t, e); case "number": return await s(t, e); case "boolean": return await o(t); case "undefined": return await m(t); case "null": return await u(t); } } const h = c(() => {}); const Ot = {}; l(Ot, { "checkResult": () => Ia }); async function Ia (t, a) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let r = t?.headers.get("content-type"); if (r && r?.includes("application/json")) try { let i = JSON.parse(a); return i || (await e(4321, "checkResult"), !1); } catch { return await e(3907, "checkResult"), !1; } else return await e(7936, "checkResult"), !1; } const Dt = c(() => {}); const Ht = {}; l(Ht, { "attemptFetch": () => va }); async function va (t) { let { "checkResult": a } = await Promise.resolve().then(() => (Dt(), Ot)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let r = 5; let i = !1; for (;r-- && i === !1;) { try { let n = await fetch(t); if (n.ok) { i = !0; let s = await n.text(); return await a(n, s); } else await e("warning", "attemptFetch"); } catch { if (r === 0) return await e(9858, "attemptFetch"), !1; } await new Promise((n) => setTimeout(n, 200)); } } const Ct = c(() => {}); const Ft = {}; l(Ft, { "fetchAxis": () => Sa }); async function Sa (t) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "attemptFetch": r } = await Promise.resolve().then(() => (Ct(), Ht)); if (await a(t, "object")) { let i = t.amount; let n = t.optimality; let s = t.timespan; let o = `https://ssd-api.jpl.nasa.gov/mdesign.api?lim=${i}&crit=${n}&year=${s}&sb-group=neo`; let u = encodeURI("https://corsproxy.io/?url=" + o); let f = await r(u); return (await a(f, "object")) ? f : (await e("warning", "fetchAxis"), !1); } else return await e(1382, "fetchAxis"), !1; } const Pt = c(() => {}); const Rt = {}; l(Rt, { "flatternObject": () => $t }); async function $t (t, a = "", e = {}, r = new Set) { for await (let i of Object.keys(t)) { let n = t[i]; if (n && typeof n == "object" && !Array.isArray(n)) await $t(n, i, e, r); else { let s = r.has(i) ? `${a}.${i}` : i; e[s] = n, r.add(i); } } return e; } const Vt = c(() => {}); const P = {}; l(P, { "axisNames": () => La }); let La; const $ = c(() => { La = { "parents": { "parents": { "name": { "original": "axis", "altName": "axis" }, "used": !0 } }, "children": { "item1": { "name": { "original": "name", "altName": "name" }, "used": !0, "validate": "checkName" }, "item2": { "name": { "original": "date0", "altName": "date0" }, "used": !0, "validate": "checkDate" }, "item3": { "name": { "original": "MJD0", "altName": "MJD0" }, "used": !0, "validate": "checkDate" }, "item4": { "name": { "original": "datef", "altName": "datef" }, "used": !0, "validate": "checkDate" }, "item5": { "name": { "original": "MJDF", "altName": "MJDF" }, "used": !0, "validate": "checkDate" }, "item6": { "name": { "original": "c3_dep", "altName": "c3_dep" }, "used": !0, "validate": "checkDigit" }, "item7": { "name": { "original": "vinf_dep", "altName": "vinf_dep" }, "used": !0, "validate": "checkDigit" }, "item8": { "name": { "original": "vinf_arr", "altName": "vinf_arr" }, "used": !0, "validate": "checkDigit" }, "item9": { "name": { "original": "dv_tot", "altName": "dv_tot" }, "used": !0, "validate": "checkDigit" }, "item10": { "name": { "original": "tof", "altName": "tof" }, "used": !0, "validate": "checkDigit" }, "item11": { "name": { "original": "class", "altName": "class" }, "used": !0, "validate": "checkFlag" }, "item12": { "name": { "original": "H", "altName": "H" }, "used": !0, "validate": "checkDigit" }, "item13": { "name": { "original": "condition_code", "altName": "condition_code" }, "used": !0, "validate": "checkDigit" }, "item14": { "name": { "original": "neo", "altName": "neo" }, "used": !0, "validate": "checkFlag" }, "item15": { "name": { "original": "pha", "altName": "pha" }, "used": !0, "validate": "checkFlag" }, "item16": { "name": { "original": "bin", "altName": "bin" }, "used": !0, "validate": "checkDigit" }, "item17": { "name": { "original": "pdes", "altName": "pdes" }, "used": !0, "validate": "checkName" } } }; }); const N = {}; l(N, { "patternTest": () => Aa }); async function Aa (t, a, e, r) { let { "errorHandle": i } = await Promise.resolve().then(() => (w(), p)); let { "patterns": n } = await Promise.resolve().then(() => (D(), O)); return n[a].test(t) ? t : (await i(e, r), !1); } const k = c(() => {}); const _t = {}; l(_t, { "checkDate": () => Oa }); async function Oa (t, a, e) { let { "patterns": r } = await Promise.resolve().then(() => (D(), O)); let { "isNully": i } = await Promise.resolve().then(() => (I(), j)); let { "patternTest": n } = await Promise.resolve().then(() => (k(), N)); if (await i(a)) return "No Value"; switch (a = String(a), t) { case e.children.item2.name.altName: case e.children.item4.name.altName: { let s = a.replace(r.pattern6, ""); return await n(s, "pattern7", 6776, "checkDate"); } case e.children.item3.name.altName: case e.children.item5.name.altName: return await n(a, "pattern9", 3903, "checkDate"); } } const Et = c(() => {}); const zt = {}; l(zt, { "checkDigit": () => Da }); async function Da (t, a, e) { let { "isNully": r } = await Promise.resolve().then(() => (I(), j)); let { "patternTest": i } = await Promise.resolve().then(() => (k(), N)); if (await r(a)) return "No Value"; switch (a = String(a), t) { case e.children.item16.name.altName: case e.children.item6.name.altName: case e.children.item13.name.altName: case e.children.item9.name.altName: case e.children.item12.name.altName: case e.children.item10.name.altName: case e.children.item8.name.altName: case e.children.item7.name.altName: return await i(a, "pattern9", 8348, "checkDigit"); } } const Kt = c(() => {}); const Ut = {}; l(Ut, { "checkFlag": () => Ha }); async function Ha (t, a, e) { let { "isNully": r } = await Promise.resolve().then(() => (I(), j)); let { "patternTest": i } = await Promise.resolve().then(() => (k(), N)); if (await r(a)) return "No Value"; switch (a = String(a), t) { case e.children.item11.name.altName: case e.children.item14.name.altName: case e.children.item15.name.altName: return await i(a, "pattern4", 1317, "checkFlag"); } } const Zt = c(() => {}); const Bt = {}; l(Bt, { "checkName": () => Ca }); async function Ca (t, a, e) { let { "isNully": r } = await Promise.resolve().then(() => (I(), j)); let { "patternTest": i } = await Promise.resolve().then(() => (k(), N)); if (await r(a)) return "No Value"; switch (a = String(a), t) { case e.children.item1.name.altName: return await i(a, "pattern10", 2516, "checkName"); case e.children.item17.name.altName: return await i(a, "pattern5", 1304, "checkName"); } } const Jt = c(() => {}); const R = {}; l(R, { "formatItem": () => Fa }); async function Fa (t, a) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); if (await e("status")) { let r = {}; let i = 0; for await (let n of Object.keys(t)) { let s = t[n]; if (s !== void 0)r[a[i]] = s; else return await e(1367, "formatItem"), !1; i++; } return r; } else return await e(6705, "formatItem"), !1; } const V = c(() => {}); const _ = {}; l(_, { "formatLoop": () => Pa }); async function Pa (t, a) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "formatItem": r } = await Promise.resolve().then(() => (V(), R)); if (await e("status")) { let i = {}; let n = 0; for await (let s of Object.keys(t)) { let o = t[s]; if (o !== void 0)i[`object${n}`] = await r(o, a); else return await e(7609, "formatLoop"), !1; n++; } return i; } else return await e(6339, "formatLoop"), !1; } const E = c(() => {}); const z = {}; l(z, { "amountInput": () => $a }); async function $a (t) { let { "spaceFormat": a } = await Promise.resolve().then(() => (S(), v)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "patternTest": r } = await Promise.resolve().then(() => (k(), N)); let i = await r(t, "pattern9", 2482, "amountInput"); if (i) { let n = (await a(String(i), "singleSpace")).toLowerCase(); return n ? Number(n) >= 1 && Number(n) <= 200 ? n : (await e(6433, "amountInput"), !1) : (await e(2764, "amountInput"), !1); } else return await e(8767, "amountInput"), !1; } const K = c(() => {}); const U = {}; l(U, { "optimalityInput": () => Ra }); async function Ra (t) { let { "spaceFormat": a } = await Promise.resolve().then(() => (S(), v)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "patternTest": r } = await Promise.resolve().then(() => (k(), N)); let i = await r(t, "pattern9", 4806, "optimalityInput"); if (i) { let n = (await a(String(i), "singleSpace")).toLowerCase(); return n ? Number(n) >= 1 && Number(n) <= 6 ? n : (await e(3380, "optimalityInput"), !1) : (await e(3052, "optimalityInput"), !1); } else return await e(2676, "optimalityInput"), !1; } const Z = c(() => {}); const B = {}; l(B, { "timespanInput": () => Va }); async function Va (t) { let { "spaceFormat": a } = await Promise.resolve().then(() => (S(), v)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "patternTest": r } = await Promise.resolve().then(() => (k(), N)); let i = await r(t, "pattern9", 1980, "timespanInput"); if (i) { let n = (await a(String(i), "singleSpace")).toLowerCase(); if (n) if (Number(n) >= 0 && Number(n) <= 20) { let s = new Date().getFullYear(); let o = 0; let m = await Promise.all(new Array(Number(n)).fill(null).map(async () => (o++, [s + o]))); return [s].concat(m).flat(1).join(","); } else return await e(8174, "timespanInput"), !1; else return await e(5826, "timespanInput"), !1; } } const J = c(() => {}); const Mt = {}; l(Mt, { "callObject": () => _a }); async function _a (t, a) { let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); let i = (await e(t, "object")) ? t : !1; let n = (await e(a, "string")) ? a : !1; if (i && n) try { return await a.split(".").reduce(async (s, o) => s[o], t); } catch { return await r(6153, "callObject"), !1; } else return await r(9274, "callObject"), !1; } const Tt = c(() => {}); const M = {}; l(M, { "manageBase": () => Ea }); async function Ea (t, a) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "callObject": r } = await Promise.resolve().then(() => (Tt(), Mt)); let { "conditionCheck": i } = await Promise.resolve().then(() => (h(), d)); let n = {}; let s = {}; if (!(await e("status"))) return !1; if (i(t, "object")) { for await (let o of Object.keys(a)) { if (!(await e("status"))) return !1; n[o] = !1; let m = await r(t, o); if (i(m, "string")) { let u = m.toLowerCase(); let f = await a[o](u); f && (n[o] = !0, s[o] = f); } else return await e(4278, "manageBase"), !1; } return Object.values(n).includes(!1) ? (await e(3603, "manageBase"), !1) : s; } } const T = c(() => {}); const Y = {}; l(Y, { "baseInput": () => za }); async function za (t) { let { "amountInput": a } = await Promise.resolve().then(() => (K(), z)); let { "optimalityInput": e } = await Promise.resolve().then(() => (Z(), U)); let { "timespanInput": r } = await Promise.resolve().then(() => (J(), B)); let { "manageBase": i } = await Promise.resolve().then(() => (T(), M)); return await i(t, { "amount": a, "optimality": e, "timespan": r }); } const q = c(() => {}); const G = {}; l(G, { "objectLoop": () => Yt }); async function Yt (t) { let { "typeID": a } = await Promise.resolve().then(() => (g(), y)); let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); if (await r("status")) { if ((await e(t, "object")) === !1) return 0; let i = 0; let n = Object.keys(t); for await (let s of n) { let o = t[s]; let m = await a(o); let u; switch (m) { case "string": case "number": case "bigint": case "boolean": case "undefined": case "array": case "null": { u = await e(o, m, 1); break; } default: u = !1; }(await e(o, "object")) ? i += await Yt(o) : u && (i += 1); } return i; } else return await r(9808, "objectLoop"), !1; } const Q = c(() => {}); const W = {}; l(W, { "resultObj": () => Ka }); async function Ka (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let e = String(t.itemData.altName); let r = t.value; let i = await t.validateImport[t.validateValue](e, r, t.nameImport[t.nameValue]); if (i) { let n = t.result; for await (let s of t.path) if (await a("status")) { let o = s; if (t.parentNames.includes(o)) { let m = t.parentList[t.parentNames.indexOf(o)]; m.used && (o = m.altName); }n[o] ? n = n[o] : n = n[o] = {}; } else return await a(1624, "resultObj"), !1; return n[t.itemData.altName] = i, t.result; } else return await a(8544, "resultObj"), !1; } const X = c(() => {}); let qt; const tt = c(() => { qt = pt({ "../manageAxis/axisNames.js": () => Promise.resolve().then(() => ($(), P)), "../manageAxis/checkDate.js": () => Promise.resolve().then(() => (Et(), _t)), "../manageAxis/checkDigit.js": () => Promise.resolve().then(() => (Kt(), zt)), "../manageAxis/checkFlag.js": () => Promise.resolve().then(() => (Zt(), Ut)), "../manageAxis/checkName.js": () => Promise.resolve().then(() => (Jt(), Bt)), "../manageAxis/formatItem.js": () => Promise.resolve().then(() => (V(), R)), "../manageAxis/formatLoop.js": () => Promise.resolve().then(() => (E(), _)), "../manageAxis/getAxis.js": () => Promise.resolve().then(() => (ct(), ot)), "../manageAxis/manageAxis.js": () => Promise.resolve().then(() => (ut(), lt)), "../manageInput/amountInput.js": () => Promise.resolve().then(() => (K(), z)), "../manageInput/baseInput.js": () => Promise.resolve().then(() => (q(), Y)), "../manageInput/manageBase.js": () => Promise.resolve().then(() => (T(), M)), "../manageInput/optimalityInput.js": () => Promise.resolve().then(() => (Z(), U)), "../manageInput/timespanInput.js": () => Promise.resolve().then(() => (J(), B)), "../manageProcess/innerLoop.js": () => Promise.resolve().then(() => (F(), C)), "../manageProcess/loopItem.js": () => Promise.resolve().then(() => (it(), nt)), "../manageProcess/objectLoop.js": () => Promise.resolve().then(() => (Q(), G)), "../manageProcess/resultObj.js": () => Promise.resolve().then(() => (X(), W)), "../manageProcess/setupItem.js": () => Promise.resolve().then(() => (et(), at)), "../manageProcess/setupLoop.js": () => Promise.resolve().then(() => (st(), rt)) }); }); let at = {}; l(at, { "setupItem": () => Ua }); async function Ua (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "resultObj": e } = await Promise.resolve().then(() => (X(), W)); let r = Object.keys(t.loop.storage)[0].toLowerCase(); let i = r.charAt(0).toUpperCase() + r.slice(1); let n = r + "Names"; let s = await qt(`../manage${i}/${n}.js`); let o = t.loop.itemData.validate; let m = await qt(`../manage${i}/${o}.js`); if (await a("status")) { let u = t.loop.path; let f = t.loop.itemData; if (Number(t.loop.childIndex) === 0 && t.loop.parent !== "" && u.length === 0 && u.push(r), f) { let x = { "itemData": f, "value": t.data.value, "nameValue": n, "nameImport": s, "validateValue": o, "validateImport": m, "parentList": t.loop.parentList, "parentNames": t.loop.parentNames, "result": t.data.result, "path": u }; let b = await e(x); return b || (await a(8328, "setupItem"), !1); } else return await a(1468, "setupItem"), !1; } else return await a(4640, "setupItem"), !1; } let et = c(() => { tt(); }); let nt = {}; l(nt, { "loopItem": () => Za }); async function Za (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "setupItem": r } = await Promise.resolve().then(() => (et(), at)); let { "innerLoop": i } = await Promise.resolve().then(() => (F(), C)); for await (let n of Object.keys(t.obj)) if (await a("status")) { let s = t.obj[n]; if ((await e(s, "array")) && (s = String(s)), !(await e(s, "object")) && !(await e(s, "array"))) { let o; let m; let u; if (t.loop1.childrenNames.includes(n)) if (m = t.loop1.childrenList[t.loop1.childrenNames.indexOf(n)], m.used) { t.parent = t.parent === "" ? Object.keys(t.storage)[0] : String(t.parent); let f = { "loop": { "parent": t.parent, "storage": t.storage, "childIndex": t.childIndex.counter, "path": t.path, "itemData": m, "parentList": t.loop1.parentList, "parentNames": t.loop1.parentNames }, "data": { "value": s, "result": t.result } }; if (u = await r(f), u)o = "validPass"; else return await a(4313, "loopItem"), !1; } else o = "ignorePass"; else o = "ignorePass"; t.loop1.itemAmount.counter++, o === "validPass" ? (m.status = !0, t.result = u, t.childIndex.counter++) : o === "ignorePass" ? t.childIndex.counter++ : await a(9561, "loopItem"); } else (await e(s, "object")) && (await i(t.loop1, s, t.storage, n, t.result, t.path.concat(n))); } else return await a(8849, "loopItem"), !1; } let it = c(() => {}); let C = {}; l(C, { "innerLoop": () => Ba }); async function Ba (t, a, e, r = "", i = {}, n = []) { let { "errorHandle": s } = await Promise.resolve().then(() => (w(), p)); let { "loopItem": o } = await Promise.resolve().then(() => (it(), nt)); if (await s("status")) { if (await o({ "loop1": t, "obj": a, "parent": r, "path": n, "childIndex": { "counter": 0 }, "storage": e, "result": i }), Number(e.amount) === Number(t.itemAmount.counter)) { for await (let f of Object.values(t.childrenList)) if (f.used === !0 && f.used !== f.status) return !1; return i; } } else return await s(9713, "innerLoop"), !1; } let F = c(() => {}); let rt = {}; l(rt, { "setupLoop": () => Ja }); async function Ja (t, a) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let { "flatternObject": r } = await Promise.resolve().then(() => (Vt(), Rt)); let { "innerLoop": i } = await Promise.resolve().then(() => (F(), C)); if (await e("status")) { let n = { "counter": 0 }; let s = {}; for await (let u of Object.keys(a.name))s[u] = {}, s[u].list = await Promise.all(Object.values(a.name[u]).map(async (f) => { let x = await r(f); return x.status = !1, x; })), s[u].name = await Promise.all(Object.values(s[u].list).map(async (f) => f.original)); let o = { "itemAmount": n, "childrenList": s.children.list, "childrenNames": s.children.name, "parentList": s.parents.list, "parentNames": s.parents.name }; let m = await i(o, t, a); return m || (await e(2233, "setupLoop"), !1); } else return await e(8194, "setupLoop"), !1; } let st = c(() => {}); const Gt = {}; l(Gt, { "valueKind": () => Ma }); async function Ma (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let r = {}; let i = {}; for await (let n of Object.keys(t))r[n] = !1; if (await e(t, "object")) { for await (let n of Object.keys(t)) { let s = t[n]; (await e(s.value, s.type)) && (r[n] = !0, i[n] = s.value); } return Object.values(r).includes(!1) ? (await a(2981, "valueKind"), !1) : i; } else return await a(6204, "valueKind"), !1; } const Qt = c(() => {}); const Wt = {}; l(Wt, { "sendProcess": () => Ta }); async function Ta (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "setupLoop": r } = await Promise.resolve().then(() => (st(), rt)); let { "valueKind": i } = await Promise.resolve().then(() => (Qt(), Gt)); if (await e(t, "object")) { let n = await i(t); if (n) { let s = Object.keys(t)[0]; let o = await r(n[s], n); return o || (await a(8361, "sendProcess"), !1); } else return await a(9122, "sendProcess"), !1; } else return await a(9122, "sendProcess"), !1; } const Xt = c(() => {}); let ot = {}; l(ot, { "getAxis": () => Ya }); async function Ya (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "fetchAxis": e } = await Promise.resolve().then(() => (Pt(), Ft)); let { "sendProcess": r } = await Promise.resolve().then(() => (Xt(), Wt)); let { "conditionCheck": i } = await Promise.resolve().then(() => (h(), d)); let { "axisNames": n } = await Promise.resolve().then(() => ($(), P)); let { "formatLoop": s } = await Promise.resolve().then(() => (E(), _)); let { "objectLoop": o } = await Promise.resolve().then(() => (Q(), G)); if (!a("status")) return !1; let m = await e(t); if (m) { let u = await s(m.data, m.fields); if (await i(u, "object")) { let f = await o(u); let b = await r({ "axis": { "type": "object", "value": u }, "amount": { "type": "number", "value": f }, "name": { "type": "object", "value": n } }); if (b) { let H = m.md_constraints; if (H) return { "data": b, "limit": H.crit, "crit": H.lim, "year": H.year }; } else return await a(5645, "getAxis"), !1; } else return await a(2619, "getAxis"), !1; } else return await a(5654, "getAxis"), !1; } let ct = c(() => {}); let lt = {}; l(lt, { "manageAxis": () => qa }); async function qa (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "getAxis": e } = await Promise.resolve().then(() => (ct(), ot)); if (!a("status")) return !1; let r = await e(t); return r || (await a(1342, "manageAxis"), !1); } let ut = c(() => {}); const ta = {}; l(ta, { "getAPI": () => Ga }); async function Ga (t) { let { "manageAxis": a } = await Promise.resolve().then(() => (ut(), lt)); let { "errorHandle": e } = await Promise.resolve().then(() => (w(), p)); let r = await a(t); return (await e("status")) ? { "axis": r } : !1; } const aa = c(() => {}); const ea = {}; l(ea, { "resultValue": () => Qa }); async function Qa (t) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), p)); let { "errorStatus": e } = await Promise.resolve().then(() => (A(), L)); return (await a("status")) ? { "status": !0, "result": t, "trace": e.errorList } : { "status": !1, "result": t, "trace": e.errorList }; } const na = c(() => {}); const ia = {}; l(ia, { "defaultValues": () => Wa }); let Wa; const ra = c(() => { Wa = { "amount": "3", "optimality": "5", "timespan": "3" }; }); const sa = {}; l(sa, { "initialValue": () => Xa }); async function Xa (t) { let { "conditionCheck": a } = await Promise.resolve().then(() => (h(), d)); let { "isNully": e } = await Promise.resolve().then(() => (I(), j)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), p)); let { "defaultValues": i } = await Promise.resolve().then(() => (ra(), ia)); let n = (await e(t)) ? {} : t; let s = {}; if (await a(n, "object", 1)) { let o = Object.keys(n); let m = Object.keys(i); if (o.length <= m.length) { for await (let u of m)o.includes(u) ? s[u] = n[u] : o.includes(u) === !1 && (s[u] = i[u]); return s; } else return await r(5465, "initialValue"), !1; } else return await r(7899, "initialValue"), !1; } const oa = c(() => {}); return (async function mt (t) { let { "getAPI": a } = await Promise.resolve().then(() => (aa(), ta)); let { "conditionCheck": e } = await Promise.resolve().then(() => (h(), d)); let { "baseInput": r } = await Promise.resolve().then(() => (q(), Y)); let { "errorHandle": i } = await Promise.resolve().then(() => (w(), p)); let { "resultValue": n } = await Promise.resolve().then(() => (na(), ea)); let { "errorStatus": s } = await Promise.resolve().then(() => (A(), L)); let { "initialValue": o } = await Promise.resolve().then(() => (oa(), sa)); let m = await o(t); if (await e(m, "object")) { let u = await r(m); if (!(await i("status"))) return !1; if (u) { let f = await a(u); return f ? await n(f) : (await i(5548, "operationAxis"), await n(s.lastError)); } else return await i(8873, "operationAxis"), await n(s.lastError); } else return await i(9324, "operationAxis"), await n(s.lastError); })(apiConfig); }
